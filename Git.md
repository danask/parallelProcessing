
Git에서 `main` 브랜치의 변경 사항만을 다른 서브 브랜치에 적용하려면, `git cherry-pick` 또는 `git merge`를 사용할 수 있습니다. 두 방법 모두 상황에 따라 유용하며, 어떤 커밋을 적용하고 싶은지에 따라 선택할 수 있습니다.

### 1. **특정 커밋을 서브 브랜치에 적용하기 (`git cherry-pick`)**

특정 커밋만을 서브 브랜치에 선택적으로 적용하려면 `git cherry-pick`을 사용합니다. 이 명령은 `main` 브랜치에서 원하는 커밋만을 선택해 현재 서브 브랜치에 반영할 수 있습니다.

#### 절차:
1. 서브 브랜치로 이동합니다.

   ```bash
   git checkout <sub-branch>
   ```

2. `main` 브랜치에서 원하는 커밋의 해시를 확인합니다.

   ```bash
   git log main
   ```

   이 명령으로 `main` 브랜치의 커밋 기록을 확인하고, 원하는 커밋의 해시를 복사합니다.

3. 특정 커밋을 서브 브랜치에 적용합니다.

   ```bash
   git cherry-pick <커밋 해시>
   ```

   하나 이상의 커밋을 적용하려면 여러 개의 커밋 해시를 공백으로 구분하여 사용할 수 있습니다:

   ```bash
   git cherry-pick <커밋1 해시> <커밋2 해시> ...
   ```

4. 충돌이 발생할 경우 수동으로 해결한 후 `git add` 명령으로 충돌을 해결하고, `git cherry-pick --continue` 명령을 실행합니다.

### 2. **`main` 브랜치의 최신 변경 사항을 서브 브랜치에 병합하기 (`git merge`)**

만약 `main` 브랜치의 변경 사항을 모두 서브 브랜치에 적용하려면 `git merge`를 사용하여 병합할 수 있습니다.

#### 절차:
1. 서브 브랜치로 이동합니다.

   ```bash
   git checkout <sub-branch>
   ```

2. `main` 브랜치의 변경 사항을 병합합니다.

   ```bash
   git merge main
   ```

   이 명령은 `main` 브랜치의 최신 커밋을 서브 브랜치에 병합합니다. 충돌이 발생할 경우 수동으로 해결한 후 `git add`를 사용하여 충돌을 해결하고 `git commit`을 실행합니다.

### 3. **서브 브랜치가 `main` 브랜치의 일부 변경 사항과 동기화될 때 (`git rebase`)**

`main` 브랜치의 변경 사항을 서브 브랜치에 적용하고 싶으나, 서브 브랜치의 커밋들을 최신 `main` 브랜치의 변경 사항 위로 재정렬하고 싶다면 `git rebase`를 사용할 수 있습니다.

#### 절차:
1. 서브 브랜치로 이동합니다.

   ```bash
   git checkout <sub-branch>
   ```

2. `main` 브랜치의 변경 사항을 재배치(Rebase)합니다.

   ```bash
   git rebase main
   ```

   이 명령은 `sub-branch`의 커밋들을 `main` 브랜치의 최신 상태 위로 재정렬합니다. 충돌이 발생할 경우 수동으로 해결한 후 `git rebase --continue`를 실행합니다.

### 요약:
- **특정 커밋만 적용**: `git cherry-pick <커밋 해시>`
- **모든 변경 사항 병합**: `git merge main`
- **커밋을 재정렬**: `git rebase main`

상황에 따라 위 방법들 중 하나를 선택하면 됩니다. `cherry-pick`은 개별 커밋을 선택적으로 적용할 때 유용하고, `merge`는 최신 변경 사항을 그대로 병합할 때, `rebase`는 서브 브랜치의 커밋을 최신 변경 사항 위로 정렬할 때 적합합니다.


-----------------------

Git에서 실수로 삭제한 파일을 복구하는 방법은 몇 가지가 있습니다. 파일을 삭제한 후 아직 `git push` 하지 않았다면, 로컬 커밋이나 스테이징 영역에서 파일을 복구할 수 있습니다. 몇 가지 복구 방법을 설명하겠습니다.

### 1. **파일이 Staging Area에 있었던 경우 (`git restore --staged`)**

만약 삭제한 파일이 Staging Area에 있었다면, `git restore` 명령을 사용해 복구할 수 있습니다:

```bash
git restore --staged <삭제한 파일 경로>
```

이 명령은 Staging Area에 있는 파일을 워킹 디렉토리로 복원합니다.

### 2. **파일이 마지막 커밋에 있었던 경우 (`git checkout`)**

파일이 이전 커밋에 존재했다면, `git checkout`을 사용하여 복구할 수 있습니다:

```bash
git checkout HEAD -- <삭제한 파일 경로>
```

이 명령은 마지막 커밋(HEAD)에서 파일을 가져와 워킹 디렉토리에 복원합니다. 파일이 마지막 커밋에 있었지만 실수로 삭제된 경우 유용합니다.

### 3. **최근 삭제한 파일 복구 (`git fsck`와 `git reflog` 활용)**

만약 파일이 이전 커밋에 없고, 실수로 삭제한 이후 새로운 커밋도 하지 않은 상태라면 `git reflog`나 `git fsck`를 사용해 파일을 복구할 수 있습니다.

#### a. `git fsck --lost-found`

Git은 삭제된 파일을 객체로 기록해두기 때문에 `git fsck` 명령어를 사용하여 이 파일을 찾을 수 있습니다:

```bash
git fsck --lost-found
```

이 명령은 삭제된 파일들을 "lost and found"로 복원할 수 있습니다. 다만, 이 파일은 원래 파일명과 경로 없이 해시로만 복구되므로, 다시 원하는 경로로 파일을 옮겨야 할 수 있습니다.

#### b. `git reflog`를 사용한 복구

`git reflog`는 Git의 모든 HEAD 이동을 추적합니다. 만약 파일을 삭제하고, `reset`, `checkout`, `commit` 등을 하면서 HEAD가 이동했다면, `reflog`를 통해 삭제 전 상태로 돌아갈 수 있습니다.

```bash
git reflog
```

이 명령은 HEAD의 모든 변경 사항을 출력합니다. 삭제된 파일이 포함된 상태로 HEAD를 되돌리려면 해당 지점으로 `reset`할 수 있습니다.

```bash
git reset <reflog에서 발견한 커밋 해시>
```

이 방법으로, 파일이 삭제되기 전의 상태로 복구할 수 있습니다.

### 4. **다시 Pull 하는데 해결되지 않는 이유**

만약 `git pull`을 해도 삭제된 파일이 복구되지 않는 이유는, 서버에 아직 `push`하지 않았기 때문입니다. `git pull`은 원격 저장소의 변경 사항을 로컬에 반영하는 명령이므로, 로컬에서 삭제된 파일이 원격에 변경된 적이 없다면 `git pull`로는 복구되지 않습니다.

### 요약

- 파일이 Staging Area에 있었으면 `git restore --staged`로 복구할 수 있습니다.
- 파일이 마지막 커밋에 있었으면 `git checkout HEAD -- <파일 경로>`로 복구합니다.
- 최근에 삭제된 파일이 Git 객체로 존재하면 `git fsck --lost-found` 또는 `git reflog`를 사용하여 복구할 수 있습니다.

이 방법들 중 하나로 실수로 삭제한 파일을 복구할 수 있을 것입니다.

------------------------


Git에서 특정 커밋으로 `master` 브랜치를 강제로 재배치(Rebase)할 수 있지만, 일반적인 `rebase` 명령은 사용하지 않습니다. 대신 `reset` 명령을 사용하여 `master` 브랜치를 특정 커밋으로 강제로 이동할 수 있습니다.

다음은 `master` 브랜치를 특정 커밋으로 강제로 리베이스(사실상 reset)하는 방법입니다:

### 1. **특정 커밋으로 `master` 브랜치를 이동 (reset)**

```bash
git checkout master
git reset --hard <커밋 해시>
```

- `<커밋 해시>`: `master` 브랜치를 이동시키고자 하는 특정 커밋의 해시 값입니다.
- `git reset --hard` 명령은 작업 디렉토리와 인덱스를 강제로 변경하여, `master` 브랜치를 지정된 커밋으로 이동시킵니다.

### 2. **원격 저장소에 강제 푸시**

로컬에서 `master` 브랜치를 특정 커밋으로 이동시킨 후, 원격 저장소에 강제로 푸시해야 합니다. 이를 위해 `--force` 옵션을 사용합니다.

```bash
git push origin master --force
```

- `--force` 옵션은 원격 브랜치의 커밋 기록을 강제로 덮어씁니다. **주의:** 이 작업은 협업 환경에서 다른 사람들의 작업에 영향을 줄 수 있으므로 신중히 사용해야 합니다.

### 3. **작업 후 확인**

`git log`를 사용하여 `master` 브랜치가 원하는 커밋을 가리키는지 확인하세요:

```bash
git log
```

이 방법으로 `master` 브랜치를 특정 커밋으로 강제로 재배치할 수 있습니다. 하지만 이 과정은 실제로는 리베이스가 아니라 `reset`이므로, 기존의 `master` 브랜치 기록이 모두 새로운 커밋으로 변경되며, 이는 협업 환경에서 주의가 필요합니다.

-------------------------
`git rebase`를 수행하는 도중에 충돌이 발생했을 때, 이를 해결하고 remote에 반영하는 절차는 다음과 같습니다:

### 1. **충돌 해결**
   - Git이 충돌이 발생한 파일을 표시해 줍니다. 충돌이 발생한 파일을 열어 충돌을 수동으로 해결하세요.
   - 충돌을 해결한 후, 해당 파일을 `git add <file>` 명령어를 사용해 Staging 합니다.

   ```bash
   git add <conflicted_file>
   ```

   충돌이 여러 파일에 걸쳐 있을 경우, 각 파일을 해결하고 Staging해야 합니다.

### 2. **Rebase 계속 진행**
   - 충돌을 해결하고 Staging한 후, rebase를 계속 진행합니다.

   ```bash
   git rebase --continue
   ```

   만약 실수로 잘못된 충돌 해결을 했다면, 아래 명령어로 충돌 해결을 취소하고 다시 시도할 수 있습니다:

   ```bash
   git rebase --abort
   ```

   이 명령어는 현재 rebase 프로세스를 중단하고, rebase를 시작하기 전 상태로 돌아갑니다.

### 3. **Rebase 완료 후 상태 확인**
   - `rebase --continue` 명령어를 사용해 모든 충돌을 해결한 후, rebase가 성공적으로 완료되었는지 확인하세요.

   ```bash
   git status
   ```

   이 명령어는 작업 트리와 스테이징된 파일들이 정리된 상태인지 보여줍니다.

### 4. **원격 저장소에 반영 (강제 푸시)**
   - Rebase가 완료되면, 로컬의 master 브랜치를 원격 저장소에 강제 푸시해야 합니다. Rebase는 기존 커밋 기록을 수정하기 때문에, 일반적인 푸시(push)로는 충돌이 발생합니다. 이를 위해 강제 푸시를 사용합니다.

   ```bash
   git push origin master --force
   ```

   `--force` 옵션을 사용하면, rebase로 변경된 커밋 기록이 강제로 원격 저장소의 master 브랜치에 반영됩니다. 주의: 강제 푸시는 다른 팀원들의 작업에 영향을 줄 수 있으므로, 협업 환경에서는 이를 신중히 사용해야 합니다.

### 5. **마무리**
   - 이제 master 브랜치는 `kcs-1.52-dev` 브랜치의 변경 사항을 성공적으로 반영했으며, 원격 저장소에도 반영되었습니다. 

이 과정을 통해 충돌을 해결하고, 로컬에서 `rebase`를 완료한 후 원격 저장소에 안전하게 반영할 수 있습니다.
